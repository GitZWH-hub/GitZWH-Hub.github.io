<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XANDER</title>
  
  <subtitle>何其荣幸</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-08-10T05:12:32.762Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Xander</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式</title>
    <link href="http://example.com/2021/07/22/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2021/07/22/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-07-22T02:59:15.755Z</published>
    <updated>2021-08-10T05:12:32.762Z</updated>
    
    <content type="html"><![CDATA[<p>&#x2003;<strong>设计模式（Design Pattern）是一套被反复使用、多人知晓的、经过分类编目的、代码设计经验的总结。</strong><br>&#x2003;使用设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码可靠性。<br>&#x2003;<strong>&lt;1&gt;</strong> 设计模式是从许多优秀的软件系统中总结出的成功的、能够实现可维护性复用的设计方案，可避免重复性工作<br>&#x2003;<strong>&lt;2&gt;</strong> 设计模式提供了一套通用的设计词汇和一种通用的形式来方便开发人员之间沟通，使得设计方案更加通俗易懂<br>&#x2003;<strong>&lt;3&gt;</strong> 大部分设计模式兼顾了系统的可重用性和可扩展性，这使得我们可以更好地重用一些已有的设计方案、功能模块甚至一个完整的软件系统，避免我们经常做一些重复的设计、编写一些重复的代码<br>&#x2003;<strong>&lt;4&gt;</strong> 有助于初学者更加深入地理解面向对象思想<br>&#x2003;狭义的设计模式一般分为三大类23种，如下表:</p><table><thead><tr><th align="center">类型</th><th align="center">种类</th></tr></thead><tbody><tr><td align="center">创建型模式</td><td align="center">单例模式，简单工厂模式，抽象工厂模式，工厂方法模式，原型模式，建造者模式</td></tr><tr><td align="center">结构型模式</td><td align="center">适配器模式，桥接模式，组合模式，装饰模式，外观模式，享元模式，代理模式</td></tr><tr><td align="center">行为型模式</td><td align="center">职责链模式，命令模式，解释器模式，迭代器模式，中介者模式，备忘录模式，观察者模式，状态模式，策略模式，模板方法模式，访问者模式</td></tr></tbody></table><p>这里只总结几个常用的</p><hr><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p><strong>定义一个简单工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类</strong><br>简单工厂模式的UML类图如下所示：<br><img src="https://yzhangwh-1253708708.cos.ap-shanghai.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Factory.png"><br>在简单工厂模式中，大体上有3个角色：<br>&lt;1&gt; <strong>工厂（Factory）</strong>：根据客户提供的具体产品类的参数，创建具体产品实例；<br>&lt;2&gt; <strong>抽象产品（AbstractProduct）</strong>：具体产品类的基类，包含创建产品的公共方法；<br>&lt;3&gt; <strong>具体产品（ConcreteProduct）</strong>：抽象产品的派生类，包含具体产品特有的实现方法，是简单工厂模式的创建目标。</p><p>考虑一个场景：</p><blockquote><p>你想要进行户外运动，你可以选择打篮球、踢足球或者玩排球。你需要凭票去体育馆场馆拿，票上写着一个具体的体育运动的名字，比如”篮球”。体育保管室负责人根据票上的字提供相应的体育用品。然后你就可以愉快地玩耍了。</p></blockquote><p><strong>定义抽象产品类AbstractProduct，抽象方法不提供实现</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class AbstractSportProduct</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">AbstractSportProduct()&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">//抽象方法：</span><br><span class="line">void printName()&#123;&#125;;</span><br><span class="line">void play()&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>定义三个具体产品类</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class Basketball :public AbstractSportProduct</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Basketball()&#123;</span><br><span class="line">printName();</span><br><span class="line">play();</span><br><span class="line">&#125;</span><br><span class="line">//具体实现方法</span><br><span class="line">void printName()&#123;</span><br><span class="line">printf(&quot;Jungle get Basketball\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void play()&#123;</span><br><span class="line">printf(&quot;Jungle play Basketball\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">//具体产品类Football</span><br><span class="line">class Football :public AbstractSportProduct</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Football()&#123;</span><br><span class="line">printName();</span><br><span class="line">play();</span><br><span class="line">&#125;</span><br><span class="line">//具体实现方法</span><br><span class="line">void printName()&#123;</span><br><span class="line">printf(&quot;Jungle get Football\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void play()&#123;</span><br><span class="line">printf(&quot;Jungle play Football\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">//具体产品类Volleyball</span><br><span class="line">class Volleyball :public AbstractSportProduct</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Volleyball()&#123;</span><br><span class="line">printName();</span><br><span class="line">play();</span><br><span class="line">&#125;</span><br><span class="line">//具体实现方法</span><br><span class="line">void printName()&#123;</span><br><span class="line">printf(&quot;Jungle get Volleyball\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void play()&#123;</span><br><span class="line">printf(&quot;Jungle play Volleyball\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>定义工厂类和工厂方法</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Factory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">AbstractSportProduct *getSportProduct(string productName)</span><br><span class="line">&#123;</span><br><span class="line">AbstractSportProduct *pro = NULL;</span><br><span class="line">if (productName == &quot;Basketball&quot;)&#123;</span><br><span class="line">pro = new Basketball();</span><br><span class="line">&#125;</span><br><span class="line">else if (productName == &quot;Football&quot;)&#123;</span><br><span class="line">pro = new Football();</span><br><span class="line">&#125;</span><br><span class="line">else if (productName == &quot;Volleyball&quot;)&#123;</span><br><span class="line">pro = new Volleyball();</span><br><span class="line">&#125;</span><br><span class="line">return pro;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>客户端使用方法</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;简单工厂模式\n&quot;);</span><br><span class="line"></span><br><span class="line">//定义工厂类对象</span><br><span class="line">Factory *fac = new Factory();</span><br><span class="line">AbstractSportProduct *product = NULL;</span><br><span class="line"> </span><br><span class="line">product = fac-&gt;getSportProduct(&quot;Basketball&quot;);</span><br><span class="line"> </span><br><span class="line">product = fac-&gt;getSportProduct(&quot;Football&quot;);</span><br><span class="line"> </span><br><span class="line">product = fac-&gt;getSportProduct(&quot;Volleyball&quot;);</span><br><span class="line"> </span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&amp;#x2003;&lt;strong&gt;设计模式（Design Pattern）是一套被反复使用、多人知晓的、经过分类编目的、代码设计经验的总结。&lt;/strong&gt;&lt;br&gt;&amp;#x2003;使用设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码可靠性。&lt;br&gt;&amp;#x2003</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>量化交易系统学习</title>
    <link href="http://example.com/2021/07/22/%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2021/07/22/%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-07-22T02:40:05.480Z</published>
    <updated>2021-09-17T05:56:48.196Z</updated>
    
    <content type="html"><![CDATA[<p>用于记录过程思路、遇到的问题和解决方法、相关知识点（杂、待整理）</p><h4 id="思考：数据准备、全端架构构建"><a href="#思考：数据准备、全端架构构建" class="headerlink" title="思考：数据准备、全端架构构建"></a>思考：数据准备、全端架构构建</h4><p>先做数据准备，有了基本数据后，思考整体的框架，做一个简单框架的搭建与实现，由后台将数据传输给前端。细节后续一步步落实。</p><h5 id="数据准备："><a href="#数据准备：" class="headerlink" title="数据准备："></a>数据准备：</h5><p>爬取历史交易日的数据，获取到数据后暂存到本地MYSQL数据库。并采用如下SQLAlchemy，使不需要操作繁琐的sql语句，转化为操作对象</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 数据库结果转化成对象，一定有一个映射规则</span><br><span class="line"># SQLAlchemy 是 Python 中一个通过 ORM 操作数据库的框架.</span><br><span class="line"># SQLAlchemy对象关系映射器提供了一种方法，用于将用户定义的Python类与数据库表相关联，</span><br><span class="line">并将这些类（对象）的实例与其对应表中的行相关联。</span><br><span class="line"># 它包括一个透明地同步对象及其相关行之间状态的所有变化的系统，称为工作单元,</span><br><span class="line">以及根据用户定义的类及其定义的彼此之间的关系表达数据库查询的系统。</span><br><span class="line"># 可以让我们使用类和对象的方式操作数据库，从而从繁琐的 sql 语句中解脱出来。</span><br><span class="line">ORM 就是 Object Relational Mapper 的简写，就是关系对象映射器的意思</span><br></pre></td></tr></table></figure><p>那读取数据后，读取到内存的也是对象，需要将对象转为json格式，如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def new_alchemy_encoder():</span><br><span class="line">    _visited_objs = []</span><br><span class="line"></span><br><span class="line">    class AlchemyEncoder(json.JSONEncoder):</span><br><span class="line">        def default(self, obj):</span><br><span class="line">            if isinstance(obj.__class__, DeclarativeMeta):</span><br><span class="line">                if obj in _visited_objs:</span><br><span class="line">                    return None</span><br><span class="line">                _visited_objs.append(obj)</span><br><span class="line"></span><br><span class="line">                # an SQLAlchemy class</span><br><span class="line">                fields = &#123;&#125;</span><br><span class="line">                for field in [x for x in dir(obj) if not x.startswith(&#x27;_&#x27;) and x != &#x27;metadata&#x27;]:</span><br><span class="line">                    data = obj.__getattribute__(field)</span><br><span class="line">                    try:</span><br><span class="line">                        # if isinstance(data, datetime):</span><br><span class="line">                        #     data = data.strftime(&#x27;%Y-%m-%d %H:%M:%S&#x27;)</span><br><span class="line">                        json.dumps(data)  # this will fail on non-encodable values, like other classes</span><br><span class="line">                        fields[field] = data</span><br><span class="line">                    except TypeError:</span><br><span class="line">                        fields[field] = None</span><br><span class="line">                return fields</span><br><span class="line"></span><br><span class="line">            return json.JSONEncoder.default(self, obj)</span><br><span class="line">    return AlchemyEncoder</span><br></pre></td></tr></table></figure><h5 id="VS-Code中import一个模块提示：Import-“MySQLdb”-could-not-be-resolved-from-source"><a href="#VS-Code中import一个模块提示：Import-“MySQLdb”-could-not-be-resolved-from-source" class="headerlink" title="VS Code中import一个模块提示：Import “MySQLdb” could not be resolved from source"></a>VS Code中import一个模块提示：Import “MySQLdb” could not be resolved from source</h5><p>解决步骤： 安装MySQLdb，但是仍然有错。<br>python2 对应的模块是MySQLdb,MySQLdb不支持python3;<br>python3对应的模块是pymysql，所以下载pymysql即可：$ pip3 install pymysql</p><h5 id="pymysql-connect-使用时报错：takes-1-positional-argument-but-5-were-given"><a href="#pymysql-connect-使用时报错：takes-1-positional-argument-but-5-were-given" class="headerlink" title="pymysql.connect()使用时报错：takes 1 positional argument but 5 were given"></a>pymysql.connect()使用时报错：takes 1 positional argument but 5 were given</h5><p>解决方法： 带上参数名称：db = pymysql.connect(host=”localhost”, user=”root”, password=”xxx”, database=”xxxx”)</p><h5 id="其他实现过程记录-动态更新"><a href="#其他实现过程记录-动态更新" class="headerlink" title="其他实现过程记录(动态更新)"></a>其他实现过程记录(动态更新)</h5><ol><li>python读取配置文件</li><li>数据库dao层封装</li><li>with、__enter__、__exit__的使用</li><li>写日志，实时查看日志</li><li>实时查看：tail -f  “日志”</li><li>Mac版Jupyter下载安装</li><li>使用spring cloud，在idea中配置python环境，缺包的话project structure中自行下载</li><li>Python服务简单运行、Flask本地测试Python</li><li>用spring cloud微服务通过sidecar调用python服务(python和java可互相调用)</li><li>Spring cloud java和python互相调用已经成功 </li></ol><p><strong>系统启动顺序：python服务、server注册中心、sidecar服务、producer、customer</strong><br>已经实现由spring cloud中Java调用python服务读取数据库数据并返回，如下图所示：<br><img src="https://yzhangwh-1253708708.cos.ap-shanghai.myqcloud.com/%E9%87%8F%E5%8C%96%E5%9B%BE%E7%89%87/%E9%87%8F%E5%8C%961.png"></p><h5 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h5><p>mac查看端口占用情况：$ sudo lsof -i:端口号<br>google chrome装一个json view的插件</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;用于记录过程思路、遇到的问题和解决方法、相关知识点（杂、待整理）&lt;/p&gt;
&lt;h4 id=&quot;思考：数据准备、全端架构构建&quot;&gt;&lt;a href=&quot;#思考：数据准备、全端架构构建&quot; class=&quot;headerlink&quot; title=&quot;思考：数据准备、全端架构构建&quot;&gt;&lt;/a&gt;思考：数</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>实习记录</title>
    <link href="http://example.com/2021/07/20/%E5%AE%9E%E4%B9%A0%E5%91%A8%E8%AE%B0%E5%BD%95/"/>
    <id>http://example.com/2021/07/20/%E5%AE%9E%E4%B9%A0%E5%91%A8%E8%AE%B0%E5%BD%95/</id>
    <published>2021-07-20T07:01:14.652Z</published>
    <updated>2021-08-09T06:18:47.479Z</updated>
    
    <content type="html"><![CDATA[<p>在研究生开学之前，来到实习公司实习以充实提高自己。记录一下这几个周的学习情况。</p><h1 id="第一周"><a href="#第一周" class="headerlink" title="第一周"></a>第一周</h1><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>项目名称：上开大教师选课系统<br>项目架构：SpringCloud微服务<br>使用对象：后勤管理人员<br>项目目的：帮助不同教师选课，满足其不同需求（合并班级、选课时间、地点等）<br><img src="https://yzhangwh-1253708708.cos.ap-shanghai.myqcloud.com/%E5%BC%80%E5%A4%A7%E4%B8%80%E5%91%A8%E5%AE%9E%E4%B9%A0%E8%AE%B0%E5%BD%95/%E9%80%89%E8%AF%BE1.png"><br>该项目使用的<a href="https://doc.xiaonuo.vip/">小诺</a>原型，可本地部署</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="BeanUtil-copyProperties-对象A-对象B"><a href="#BeanUtil-copyProperties-对象A-对象B" class="headerlink" title="BeanUtil.copyProperties(对象A, 对象B)"></a>BeanUtil.copyProperties(对象A, 对象B)</h3><p>作用：进行对象间属性的赋值，避免get、set，把对象A的属性赋值给对象B</p><h3 id="Maven：项目管理工具"><a href="#Maven：项目管理工具" class="headerlink" title="Maven：项目管理工具"></a>Maven：项目管理工具</h3><p>主要做了两件事：1统一开发规范与工具、2统一管理jar包</p><h3 id="Spring-Bean到底是什么？"><a href="#Spring-Bean到底是什么？" class="headerlink" title="Spring Bean到底是什么？"></a>Spring Bean到底是什么？</h3><p>Bean在Spring和Spring MVC随处可见。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1)Java面向对象，对象有方法和属性，那么就需要对象实例来调用方法和属性（即实例化）；</span><br><span class="line">(2)凡是有方法或属性的类都需要实例化，这样才能具象化去使用这些方法和属性；</span><br><span class="line">(3)规律：凡是子类及带有方法或属性的类都要加上注册Bean到Spring IoC的注解；</span><br><span class="line">（@Component , @Repository , @ Controller , @Service , @Configration）</span><br><span class="line">(4)把Bean理解为类的代理人（实际上是通过反射、代理来实现的），这样它就能代表类拥有该有的东西了。</span><br><span class="line">(5)微博@某某，对方会优先看到这条信息，并给你反馈。在Spring中，标识一个@符号，那么Spring就会来看看，并从这里拿到一个Bean注册或给出一个Bean使用</span><br></pre></td></tr></table></figure><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>Redis是高性能的key-value数据库，特点：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.数据持久化，可以将内存中数据保存在磁盘中，重启时可以再次加载使用</span><br><span class="line">2.不仅仅支持简单的key-value形式，同时还提供list、set、hash等结构的存储</span><br><span class="line">3.master-slave模式的数据备份</span><br></pre></td></tr></table></figure><p>性能极高、丰富的数据类型、原子性</p><h3 id="QueryWrapper"><a href="#QueryWrapper" class="headerlink" title="QueryWrapper"></a>QueryWrapper</h3><p>queryWrapper是mybatis plus中实现查询的对象封装操作<br><img src="https://yzhangwh-1253708708.cos.ap-shanghai.myqcloud.com/%E5%BC%80%E5%A4%A7%E4%B8%80%E5%91%A8%E5%AE%9E%E4%B9%A0%E8%AE%B0%E5%BD%95/queryWapper.png"></p><h3 id="寻找文件"><a href="#寻找文件" class="headerlink" title="寻找文件"></a>寻找文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># mdfind -name 文件名称</span><br></pre></td></tr></table></figure><h3 id="启动vue"><a href="#启动vue" class="headerlink" title="启动vue"></a>启动vue</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cd myvue</span><br><span class="line"># npm run dev</span><br></pre></td></tr></table></figure><hr><h1 id="第二周"><a href="#第二周" class="headerlink" title="第二周"></a>第二周</h1><p>本周学习内容有：选课系统本地环境部署搭建、尝试开发</p><h2 id="服务搭建"><a href="#服务搭建" class="headerlink" title="服务搭建"></a>服务搭建</h2><h3 id="所需软件"><a href="#所需软件" class="headerlink" title="所需软件"></a>所需软件</h3><p><strong>A、 IntelliJ Idea: “用于Java后台和前端vue开发”</strong><br><strong>B、 Redis:  “一款内存高速缓存数据库, 支持key-value等多种数据结构”</strong><br>Redis特点：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1)由于以内存作为存储介质，读写数据效率极高</span><br><span class="line">(2)redis跟内存不同的是：储存在redis中的数据是持久化的，断电也不会丢失</span><br><span class="line">(3)redis存储分为内存存储、磁盘存储和log存储</span><br><span class="line">(4)redis可以从磁盘将数据重新加载到内存，因此才实现持久化</span><br><span class="line">但Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</span><br></pre></td></tr></table></figure><p>Redis应用场景：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">因为redis交换数据快，在服务器中常用来存储一些需要频繁调用的数据，节省内存开销，也极大地提升了速度</span><br><span class="line">(1)会话缓存（最常用）</span><br><span class="line">(2)消息队列（支付）</span><br><span class="line">(3)发布、订阅消息（消息通知）</span><br><span class="line">(4)商品列表、评论列表</span><br></pre></td></tr></table></figure><p>Redis一共支持五种数据类型：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String（字符串）、hash（哈希）、list（列表）、set（集合）和zset（sorted  set有序集合）</span><br></pre></td></tr></table></figure><p><strong>C、 Node.js: “是一种通过JavaScript语言开发web服务端的东西”</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">特性：非阻塞、事件驱动IO</span><br><span class="line">非阻塞：将服务器想像成一个loop循环，loop会一直跑下去。一个新的请求来了，loop就接受这个请求，把请求传递给其他进程，如查询数据库的进程，并响应一个回掉。完事了loop接着跑，接其他的请求。这样服务器就不会傻等着接数据库返回的结果。</span><br><span class="line">事件驱动：从理论上说，这样同一时刻的数据库查询数量，以及用户的请求数量就没有限制了。服务器只在用户那边有事件发生的时候才响应，这就是事件驱动。</span><br></pre></td></tr></table></figure><p><strong>D、 Vue前端</strong><br><strong>E、 MySql数据库</strong></p><h3 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h3><p><strong>数据库导入本地</strong><br><strong>后端服务启动顺序</strong><br>(1)SundeNacosApp (2)SundeActuatorApp (3)SundeGatewayApp (4)SundeMainApp<br><strong>vue服务启动</strong><br>cd到前端代码的_web文件夹下，执行以下命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># npm run serve</span><br></pre></td></tr></table></figure><p>为方便起见，本地编辑shell脚本vue.sh<br><strong>本地访问验证<a href="http://localhost:9000/">local</a></strong><br><strong>遇到的问题及解决办法</strong><br>(1) 编译<br>Maven (root)下，先clean再compile<br>(2) 编译过程中遇到缺少某个<br>双击进入代码文件，定位后点击母模块，进行Build，再重新compile<br>(3) 连接数据库出错<br>修改配置文件，连接本地</p><h2 id="上手开发情况"><a href="#上手开发情况" class="headerlink" title="上手开发情况"></a>上手开发情况</h2><p>目前，已经可以在前端修改界面，发送Data到后台服务，并存储到本地MySql数据库。<br>在【假期设置】菜单中添加Button【Send Message】，如图1：<br><img src="https://yzhangwh-1253708708.cos.ap-shanghai.myqcloud.com/%E5%BC%80%E5%A4%A7%E4%BA%8C%E5%91%A8%E5%AE%9E%E4%B9%A0%E8%AE%B0%E5%BD%95/%E9%80%89%E8%AF%BE1.png"></p><center>图1</center><p>点击按钮，弹出对话框Form，编辑信息，如图2：<br><img src="https://yzhangwh-1253708708.cos.ap-shanghai.myqcloud.com/%E5%BC%80%E5%A4%A7%E4%BA%8C%E5%91%A8%E5%AE%9E%E4%B9%A0%E8%AE%B0%E5%BD%95/%E9%80%89%E8%AF%BE2.png"></p><center>图2</center><p>点击确定，发送message给后端，并保存到了本地数据库，如图3：<br><img src="https://yzhangwh-1253708708.cos.ap-shanghai.myqcloud.com/%E5%BC%80%E5%A4%A7%E4%BA%8C%E5%91%A8%E5%AE%9E%E4%B9%A0%E8%AE%B0%E5%BD%95/%E9%80%89%E8%AF%BE3.png"></p><center>图3</center>也添加了点击按钮【Go to Major Page】跳转菜单，计划跳转界面并携带数据<p>弹出框（下面代码效果为上图2）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;a-modal</span><br><span class="line">    title=&quot;Send Message&quot;</span><br><span class="line">    :width=&quot;1000&quot;</span><br><span class="line">    :visible=&quot;visible&quot;</span><br><span class="line">    :confirmLoading=&quot;confirmLoading&quot;</span><br><span class="line">    @ok=&quot;handleSubmit&quot;</span><br><span class="line">    @cancel=&quot;handleCancel&quot;</span><br><span class="line">    &gt;</span><br><span class="line">    &lt;a-spin :spinning=&quot;confirmLoading&quot;&gt;</span><br><span class="line">      &lt;a-form :form=&quot;form&quot;&gt;</span><br><span class="line">        &lt;a-form-item</span><br><span class="line">          label=&quot;Name&quot;</span><br><span class="line">          :labelCol=&quot;labelCol&quot;</span><br><span class="line">          :wrapperCol=&quot;wrapperCol&quot;</span><br><span class="line">          has-feedback</span><br><span class="line">        &gt;</span><br><span class="line">          &lt;a-input placeholder=&quot;Enter your name&quot; v-decorator=&quot;[&#x27;s_name&#x27;]&quot; /&gt;</span><br><span class="line">        &lt;/a-form-item&gt;</span><br><span class="line">        &lt;a-form-item</span><br><span class="line">          label=&quot;Age&quot;</span><br><span class="line">          :labelCol=&quot;labelCol&quot;</span><br><span class="line">          :wrapperCol=&quot;wrapperCol&quot;</span><br><span class="line">          has-feedback</span><br><span class="line">        &gt;</span><br><span class="line">          &lt;a-input placeholder=&quot;Enter your age&quot; v-decorator=&quot;[&#x27;s_age&#x27;]&quot; /&gt;</span><br><span class="line">        &lt;/a-form-item&gt;</span><br><span class="line">        &lt;a-form-item</span><br><span class="line">          label=&quot;Address&quot;</span><br><span class="line">          :labelCol=&quot;labelCol&quot;</span><br><span class="line">          :wrapperCol=&quot;wrapperCol&quot;</span><br><span class="line">          has-feedback</span><br><span class="line">        &gt;</span><br><span class="line">          &lt;a-input placeholder=&quot;Enter your address&quot; v-decorator=&quot;[&#x27;s_address&#x27;]&quot; /&gt;</span><br><span class="line">        &lt;/a-form-item&gt;</span><br><span class="line"></span><br><span class="line">        &lt;a-button type=&quot;primary&quot; v-if=&quot;hasPerm(&#x27;kdHoliday:modify&#x27;)&quot; icon=&quot;plus&quot; @click=&quot;close&quot;&gt;Go to Major Page&lt;/a-button&gt;</span><br><span class="line">        </span><br><span class="line">      &lt;/a-form&gt;</span><br><span class="line">    &lt;/a-spin&gt;</span><br><span class="line">  &lt;/a-modal&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><hr><h1 id="第三周"><a href="#第三周" class="headerlink" title="第三周"></a>第三周</h1><p>本周学习内容有：Vue前端深度学习、后台修改</p><h2 id="知识点及问题整理"><a href="#知识点及问题整理" class="headerlink" title="知识点及问题整理"></a>知识点及问题整理</h2><h3 id="vue前端"><a href="#vue前端" class="headerlink" title="vue前端"></a><strong>vue前端</strong></h3><p><strong>(1) Object.assign()</strong><br>对象的拷贝与合并（深？浅？）<br><strong>(2) 问题：表中存在所查询数据，但查询字段返回为null</strong><br>原因：数据库中的字段名为使用下划线连接，所以对应的实体类应该是驼峰命名方式，但实际类中采用的下划线连接，所以queryWrapper映射不到。<br>解决方法：1. 修改map-underscore-to-camel-case: false   2. 或者将实体类命名改为驼峰方式<br>按道理应该可以解决,且确实解决了查询为null的问题。<br>最终解决：修改了数据库表的列名<br><strong>(3) vue前端查看日志</strong><br>用Google Chrome来运行，找到开发者模式，可以查看</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">window.console.log(要查看内容)</span><br></pre></td></tr></table></figure><p><strong>(4) label的使用</strong><br>如果label是做查询条件，使用v-model</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a-form-item</span><br><span class="line">    label=&quot;Name&quot;</span><br><span class="line">    :labelCol=&quot;labelCol&quot;</span><br><span class="line">    :wrapperCol=&quot;wrapperCol&quot;</span><br><span class="line">    has-feedback</span><br><span class="line">&gt;</span><br><span class="line">    &lt;a-input placeholder=&quot;Enter name&quot; v-model=&quot;queryParam.name&quot; /&gt;</span><br><span class="line">&lt;/a-form-item&gt;</span><br></pre></td></tr></table></figure><p>v-model跟v-decorator不能同时使用<br><strong>(5) vue表格</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 列表添加 --&gt;</span><br><span class="line">&lt;a-card :bordered=&quot;false&quot;&gt;</span><br><span class="line">  &lt;s-table</span><br><span class="line">    ref=&quot;table&quot;</span><br><span class="line">    :columns=&quot;columns&quot;</span><br><span class="line">    :data=&quot;loadData&quot;</span><br><span class="line">    :rowKey=&quot;(record) =&gt; record.id&quot;</span><br><span class="line">    bordered</span><br><span class="line">  &gt;</span><br><span class="line">  &lt;/s-table&gt;</span><br><span class="line">&lt;/a-card&gt;</span><br></pre></td></tr></table></figure><p>data(){ return { :</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">queryParam: &#123;&#125;,     //查询参数</span><br><span class="line">columns: [          //列名参数</span><br><span class="line">   &#123;</span><br><span class="line">      title: &#x27;Name&#x27;,</span><br><span class="line">      align: &#x27;center&#x27;,</span><br><span class="line">      dataIndex: &#x27;name&#x27;</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">      title: &#x27;Address&#x27;,</span><br><span class="line">      align: &#x27;center&#x27;,</span><br><span class="line">      dataIndex: &#x27;address&#x27;</span><br><span class="line">   &#125;</span><br><span class="line">],</span><br><span class="line">tstyle: &#123; &#x27;padding-bottom&#x27;: &#x27;0px&#x27;, &#x27;margin-bottom&#x27;: &#x27;10px&#x27; &#125;,</span><br><span class="line">loadData: parameter =&gt; &#123;    // 加载数据方法 必须为 Promise 对象</span><br><span class="line">return MsgDemand(Object.assign(parameter, this.tojason())).then((res) =&gt; &#123;</span><br><span class="line">    return res.data</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">tojason()&#123;</span><br><span class="line">    const obj = JSON.parse(JSON.stringify(this.queryParam))</span><br><span class="line">    return obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(6) 后续继续实现修改和删除功能、单击表中一套记录显示详细信息</strong></p><h3 id="Java后台"><a href="#Java后台" class="headerlink" title="Java后台"></a><strong>Java后台</strong></h3><p><strong>(1) baseMapper.selectOne(queryWrapper)的使用</strong><br>前提：已知只有一条记录才可以使用<br><strong>(2) (Java后端)queryWrapper的代码使用(在第一周记录里已有简单介绍)</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public PageResult&lt;Message&gt; demand(MessageParam MsgParam)&#123;</span><br><span class="line">    QueryWrapper&lt;Message&gt; queryWrapper = new QueryWrapper&lt;&gt;();</span><br><span class="line">    System.out.println(MsgParam);</span><br><span class="line">    if (ObjectUtil.isNotNull(MsgParam)) &#123;</span><br><span class="line">        if (ObjectUtil.isNotEmpty(MsgParam.getName())) &#123;            // 根据名称 查询</span><br><span class="line">            queryWrapper.lambda().eq(Message::getName, MsgParam.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        if (ObjectUtil.isNotEmpty(MsgParam.getAddress())) &#123;         // 根据地址模糊 查询</span><br><span class="line">            queryWrapper.lambda().like(Message::getAddress, MsgParam.getAddress());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new PageResult&lt;&gt;(this.page(PageFactory.defaultPage(), queryWrapper));</span><br><span class="line">&#125;</span><br><span class="line">//另外，如果已知只有一条数据，也可以直接返回Message，        </span><br><span class="line">//使用selectOne的前提是：已经知道只有一条记录的前提</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    Message msg = baseMapper.selectOne(queryWrapper);</span><br><span class="line">    return msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="至此，已经可以实现"><a href="#至此，已经可以实现" class="headerlink" title="至此，已经可以实现"></a>至此，已经可以实现</h3><p><strong>(1) 修改前端界面，并将数据传递给后端并保存到数据库</strong><br><strong>(2) 根据条件查询后台，并返回给前端显示，(支持多条件、不同条件查询)</strong><br><strong>A: 查询全部</strong><br><img src="https://yzhangwh-1253708708.cos.ap-shanghai.myqcloud.com/%E5%BC%80%E5%A4%A7%E4%B8%89%E5%91%A8%E5%AE%9E%E4%B9%A0%E8%AE%B0%E5%BD%95/Demand%20All.png"><br><strong>B: 单条件查询</strong><br><img src="https://yzhangwh-1253708708.cos.ap-shanghai.myqcloud.com/%E5%BC%80%E5%A4%A7%E4%B8%89%E5%91%A8%E5%AE%9E%E4%B9%A0%E8%AE%B0%E5%BD%95/Demand%20OneCon.png"><br><strong>C: 多条件查询</strong><br><img src="https://yzhangwh-1253708708.cos.ap-shanghai.myqcloud.com/%E5%BC%80%E5%A4%A7%E4%B8%89%E5%91%A8%E5%AE%9E%E4%B9%A0%E8%AE%B0%E5%BD%95/Demand%20MoreCon.png"><br><strong>D: 模糊条件查询</strong><br><img src="https://yzhangwh-1253708708.cos.ap-shanghai.myqcloud.com/%E5%BC%80%E5%A4%A7%E4%B8%89%E5%91%A8%E5%AE%9E%E4%B9%A0%E8%AE%B0%E5%BD%95/Demand%20Like.png"></p><hr><h1 id="第四周"><a href="#第四周" class="headerlink" title="第四周"></a>第四周</h1><p>第四周周学习内容有：数据整理、Java读写文件、Xapi和MongoDB理解</p><h2 id="Java读取Excel文件与写txt文件（样本数据的整理Jason格式）"><a href="#Java读取Excel文件与写txt文件（样本数据的整理Jason格式）" class="headerlink" title="Java读取Excel文件与写txt文件（样本数据的整理Jason格式）"></a>Java读取Excel文件与写txt文件（样本数据的整理Jason格式）</h2><p><strong>读取Excel并加载到内存</strong><br>需要依赖Jar包（jxl.jar包），下载该包并引入（File——&gt;Project Structure——&gt;Modules——&gt; +加号引入）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">File f = new File(&quot;Excel文件地址&quot;);</span><br><span class="line">Workbook book = Workbook.getWorkbook(f);</span><br><span class="line">List&lt;List&lt;String&gt;&gt; list = new ArrayList&lt;&gt;();    //内存数据结构List</span><br><span class="line">Sheet sheet=book.getSheet(0);                   //获得第一个工作表对象</span><br><span class="line">for(int i = 1; i &lt; sheet.getRows(); i++) &#123;</span><br><span class="line">    List&lt;String&gt; a = new ArrayList&lt;&gt;();</span><br><span class="line">    for (int j = 0; j &lt; sheet.getColumns(); j++) &#123;</span><br><span class="line">        Cell cell = sheet.getCell(j, i);  //获得单元格</span><br><span class="line">        a.add(cell.getContents());</span><br><span class="line">    &#125;</span><br><span class="line">    list.add(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>写txt文件</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">File writename = new File(&quot;txt文件地址名称&quot;);</span><br><span class="line">writename.createNewFile();</span><br><span class="line">BufferedWriter out = new BufferedWriter(new FileWriter(writename));</span><br><span class="line">out.write(&quot;写内容&quot;);</span><br><span class="line">out.flush();</span><br><span class="line">out.close();</span><br></pre></td></tr></table></figure><p><strong>读txt文件</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Reader fr = null;</span><br><span class="line">int length = 0;</span><br><span class="line">char ch [] = null;</span><br><span class="line">//创建字符输入流对象，负责读取文件</span><br><span class="line">try &#123;</span><br><span class="line">    //fr =new FileReader(&quot;/Users/zhangwh/Downloads/text.txt&quot;);</span><br><span class="line">    fr =new FileReader(&quot;/Users/zhangwh/Downloads/汇总.xlsx&quot;);</span><br><span class="line">    //创建中转站数组，存放读取的内容</span><br><span class="line">    ch = new char[1024];</span><br><span class="line">    //读取文件内容到ch数组中</span><br><span class="line">    length = fr.read(ch);</span><br><span class="line">    //输出保存在ch数组中文件内容</span><br><span class="line">    System.out.println(new String(ch ,0,length));</span><br><span class="line"></span><br><span class="line">&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">    // TODO Auto-generated catch block</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; finally&#123;</span><br><span class="line">    if(null!=fr)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            fr.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            // TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java控制台输入</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Scanner input=new Scanner(System.in);</span><br><span class="line">int m = input.nextInt();</span><br></pre></td></tr></table></figure><h3 id="整理样本的过程"><a href="#整理样本的过程" class="headerlink" title="整理样本的过程"></a>整理样本的过程</h3><p>从文档里手动整理的Excel文件，包含了原句、主语、谓语、宾语、类别（概念/包含）<br>之后由上述程序读取Excel文件转成txt文本（key-value的jason格式）</p><hr><h1 id="第五周"><a href="#第五周" class="headerlink" title="第五周"></a>第五周</h1><h2 id="Xapi、MongoDB了解"><a href="#Xapi、MongoDB了解" class="headerlink" title="Xapi、MongoDB了解"></a>Xapi、MongoDB了解</h2><h3 id="Xapi"><a href="#Xapi" class="headerlink" title="Xapi"></a>Xapi</h3><p><strong>概述</strong><br>&#x2003;Xapi是Xen Server中的一组管理接口的统称，是其管理的核心，由一系列的toolstack组成。<br>&#x2003;Xapi主要提供哥客户端以及Pool中各主机通信的接口。客户端可以通过Xapi来读取Xen Server的配置、管理、License的管理、数据库的维护等等，同时也包括如存储、虚机、虚拟网卡、HA等资源的功能管理及控制。Xapi接口必须保持向后兼容，允许较老版本的客户端可以正常工作。<br><strong>运行环境</strong><br>&#x2003;在Xen中最基础的概念是资源池（Pool）–整体集群作为单个实体进行管理。即使单个Xen Host的非集群环境，Xapi对资源对象的管理也是通过Pool 来完成的。Xapi运行在主机集群中，他们共享着部分存储集群。这部分共享存储也是建立高可用集群（HA）的前提保证。下图展示的是运行着Xapi的主机集群环境。<br><img src="https://yzhangwh-1253708708.cos.ap-shanghai.myqcloud.com/%E5%BC%80%E5%A4%A7%E5%9B%9B%E5%91%A8%E5%AE%9E%E4%B9%A0%E8%AE%B0%E5%BD%95/Xapi.png"><br>&#x2003;在任何时候，最多只有一个主机可以被称为Pool Mater，它用来负责协调和锁定资源池的资源。首次创建Pool时，需要指定一台机器为Pool Master，这台机器则称为 Master Host（主节点），其他节点我们可以称之为Slave Host（从节点）。Pool Master角色也并非一成不变的。我们可以通过XenCenter等客户端手动调整 Master Host节点；也可配置HA的集群通过Xen自身的HA机制在Master Host宕机时，自动选举新的节点为Master Host。<br>&#x2003;所有主机都会提供两种协议的接口，一个是使用80端口的HTTP和XML/RPC协议接口以及使用443端口的TLS/SSL协议接口。虽然存在着这两种接口协议，但并不是所有主机都能够通过Xapi来下发操作请求的，在集群中仅Master Host具有着接受Xapi操作请求的权限。如若尝试将控制操作的请求发送到另一台Slave Host的机器，将导致XenAPI重定向返回一个错误消息，该错误消息包含有这台机器所处集群的Master Host的地址，以及详细错误提示。</p><p>&#x2003;作为 Pool Master除了上文提及配置HA后的自动迁移还会以有序的方式处理或转发用户请求（xe pool-designate-new-master）以及处理或转发在紧急情况下的用户请求（xe pool-emergency-transition-to-master）。</p><p>&#x2003;Slave Host节点并不是完全不能接受任何操作。为了提高效率，在Slave Host上允许进行以下操作：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查询性能计数器（及其历史记录）</span><br><span class="line">连接到VNC控制台</span><br><span class="line">导入/导出（特别是当磁盘在本地存储上时）</span><br></pre></td></tr></table></figure><p>&#x2003;由于Master Host充当协调器和锁定管理器的角色，因此其他主机通常会与Master Host通信。Slave Host也会相互通信（通过相同的HTTP和XMLRPC通道）来完成以下功能</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">传输VM内存映像（VM迁移）</span><br><span class="line">镜像磁盘（存储迁移）</span><br></pre></td></tr></table></figure><p>&#x2003;要注意的是，某些类型的共享存储（特别是所有使用vhd的存储）需要协调磁盘GC和合并。这种协调目前由Xapi完成，因此不可能在资源池之间共享这种存储。<br><strong>工作机制</strong><br>&#x2003;Xapi分为以下类别：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">master-only：这些是当前主要的API请求类型。客户端API请求Master节点，Master节点转发请求到相应的机器并锁定相应资源。</span><br><span class="line">normal-local：这些是对性能有着特殊要求的情况，允许从节点去调用的API。例如磁盘导入/导出和控制台连接等，它们直接发送到对数据到相关主机，不必经过Master节点的转发。</span><br><span class="line">· emergency：是处理Master Host离线这种紧急情况下使用的API请求类型。</span><br></pre></td></tr></table></figure><p>&#x2003;主机在接受到API请求后，先判断本机可以接受该类型的请求，如果可以执行，API调用就会进入“消息转发”层。</p><p>&#x2003;消息转发层将会</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">锁定资源（通过current_operations机制实现）</span><br><span class="line">选择需要执行请求的主机</span><br></pre></td></tr></table></figure><p>&#x2003;如果请求应在本地运行，则使用直接函数调用; 否则，消息转发代码会对特定的Slave Host进行同步API调用。需注意的是Xapi目前使用“thread per request”（一个线程处理一个请求）模型，该模型会为每个请求创建一个完整的POSIX线程。即使仅转发请求，这个线程仍然会被创建，并会一直阻塞直至相关Slave Host返回结果。</p><p>&#x2003;如果XenAPI请求内容是VM生命周期相关的操作，它将转换为Xenopsd API调用并通过Unix域套接字进行转发。Xapi和Xenopsd都有类似的task的概念，当前的Xapi task（所有操作在task的上下文中运行）会被绑定到Xenopsd task上，之后Xapi还会用来传递取消操作和更新task进度。</p><p>&#x2003;如果XenAPI请求内容为存储操作，则将消息转发至“存储访问”层。存储访问层需</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">验证存储对象是否处于正确状态（验证SR挂载状态；VDI挂载、激活 以及VDI是否具有读写权限）</span><br><span class="line">调用Storage Manager API（SMAPI）v2接口中的相关操作</span><br><span class="line">使用SMAPIv2到SMAPIv1转换器生成必要的命令行来与SMAPIv1插件（EXT，NFS，LVM等）通信并执行</span><br><span class="line">将存储对象的状态（包括VDI.attach调用的结果）持久化</span><br></pre></td></tr></table></figure><p>&#x2003;在内部，smapiv1插件通过对xapi数据库的特权访问来直接设置字段（例如VDI.virtual_size），这些字段将被视为对其他客户端是只读的。SMAPIv1插件也依赖于Xapi</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">了解可能访问存储的所有主机</span><br><span class="line">锁定资源池中的磁盘</span><br><span class="line">通过“Xapi插件”机制在其他主机上安全地执行代码</span><br></pre></td></tr></table></figure><p>&#x2003;Xapi数据库包含主机和VM的元数据，并共享给整个Pool。Master Host会在内存中缓存一份副本，所有其他节点在使用时会查询Master Host中缓存的数据。数据库将每个对象都会有一个事件计数器，生成计数器用于实现XenAPI中event.next和event.from的相关操作。如果启用了“redo-log”， 那么所有数据库写入操作都会以增量的形式同步写入共享块设备。如果不使用redo-log”在刷新之前取消Xapi则可能会丢失最近的更新。</p><h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><p>(1) MongoDB是一款强大、灵活、且易于扩展的通用型数据库<br>(2) MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统,是面向文档的，而非关系型数据库。<br>(3) 在高负载的情况下，添加更多的节点，可以保证服务器性能。<br>(4) MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。<br>(5) MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。<br>&#x2003;<strong>sql术语与mongodb术语对比</strong><br><img src="https://yzhangwh-1253708708.cos.ap-shanghai.myqcloud.com/%E5%BC%80%E5%A4%A7%E5%9B%9B%E5%91%A8%E5%AE%9E%E4%B9%A0%E8%AE%B0%E5%BD%95/mongodb.png"><br>&#x2003;<strong>数据逻辑层次关系：文档 =&gt; 集合 =&gt; 数据库</strong><br><img src="https://yzhangwh-1253708708.cos.ap-shanghai.myqcloud.com/%E5%BC%80%E5%A4%A7%E5%9B%9B%E5%91%A8%E5%AE%9E%E4%B9%A0%E8%AE%B0%E5%BD%95/mongodb2.png"><br>&#x2003;通过对比，我们了解到，在关系型数据库中每一行的数据对应mongodb里是一个文档。mongodb的文档是以BSON（binary json）格式存储的，其格式就是json格式。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    name: &quot;sue&quot;,</span><br><span class="line">    age: 26,</span><br><span class="line">    status: &quot;A&quot;,</span><br><span class="line">    groups: [&quot;news&quot;, &quot;sports&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在研究生开学之前，来到实习公司实习以充实提高自己。记录一下这几个周的学习情况。&lt;/p&gt;
&lt;h1 id=&quot;第一周&quot;&gt;&lt;a href=&quot;#第一周&quot; class=&quot;headerlink&quot; title=&quot;第一周&quot;&gt;&lt;/a&gt;第一周&lt;/h1&gt;&lt;h2 id=&quot;项目介绍&quot;&gt;&lt;a href=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>SpringBoot、SpringCloud学习记录</title>
    <link href="http://example.com/2021/07/20/Spring%20Boot%E3%80%81Spring%20Cloud%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>http://example.com/2021/07/20/Spring%20Boot%E3%80%81Spring%20Cloud%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</id>
    <published>2021-07-20T02:16:25.803Z</published>
    <updated>2021-07-22T02:58:46.075Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Spring-Boot"><a href="#1-Spring-Boot" class="headerlink" title="1. Spring Boot"></a>1. Spring Boot</h2><p>简单步骤</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1)建立实体类，跟数据库表字段保持一致        #entity包中只做映射</span><br><span class="line">(2)建立mapper接口，定义要操作数据库的动作</span><br><span class="line">(3)建立mapper的xml文件，写具体的SQL语句</span><br><span class="line">(4)建立service类，处理业务逻辑</span><br><span class="line">(5)在controller类中展示处理结果           #Controller提供访问入口</span><br></pre></td></tr></table></figure><p>针对此过程，自己写了一段代码demo1：可实现查询本地MySql数据库并将数据传给前端(jason格式)</p><p>注意事项</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1)Pom文件里面添加依赖，如mybatis依赖</span><br><span class="line">(2)没有@Mapper注解。</span><br><span class="line">   添加依赖：</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.3.2&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">(3)本地数据库启动：在设置中</span><br><span class="line">(4)resources的mapper配置文件xml从一行写</span><br></pre></td></tr></table></figure><h4 id="不同注解的作用"><a href="#不同注解的作用" class="headerlink" title="不同注解的作用"></a>不同注解的作用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ Controller:</span><br><span class="line">标识一个该类是Spring MVC controller处理器，用来创建处理http请求的对象。</span><br><span class="line">@ RestController:</span><br><span class="line">原来在Controller中返回json需要@ResponseBody来配合，如果直接用RestController来替代Controller就不需要再配置ResponseBody，默认返回json格式。</span><br><span class="line">@ Service:</span><br><span class="line">用于标注业务层组件，说白了就是用注解的方式将这个类注入到Spring配置中。</span><br><span class="line">@ Autowired:</span><br><span class="line">用来装配Bean，都可以写在字段上或者方法上。默认情况下必须要求依赖对象必须存在，如果允许NULL值，可以@ Autowired(required=false)</span><br><span class="line">@ Resource:</span><br><span class="line">作用相当于Autowired，只不过Autowired是按byType自动注入，而Resource默认按byName自动注入罢了。</span><br><span class="line">@ GetMapping:</span><br><span class="line">用于处理请求方法的get类型</span><br></pre></td></tr></table></figure><h2 id="2-Spring-Cloud"><a href="#2-Spring-Cloud" class="headerlink" title="2. Spring Cloud"></a>2. Spring Cloud</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Provider/Producer：暴露服务的服务提供方</span><br><span class="line">Consumer/Customer：调用远程服务的服务消费方</span><br><span class="line">Eureka Server：服务注册中心和服务发现中心</span><br></pre></td></tr></table></figure><p><img src="https://yzhangwh-1253708708.cos.ap-shanghai.myqcloud.com/%E5%BC%80%E5%A4%A7%E4%B8%80%E5%91%A8%E5%AE%9E%E4%B9%A0%E8%AE%B0%E5%BD%95/springcloud1.png"><br>服务注册：将服务所在的主机、端口、版本号、通信协议等信息登记到注册中心。<br>服务发现：服务消费者向注册中心请求已经登记的服务列表，然后得到某个服务的..信息，从而实现对具体服务的调用。<br><img src="https://yzhangwh-1253708708.cos.ap-shanghai.myqcloud.com/%E5%BC%80%E5%A4%A7%E4%B8%80%E5%91%A8%E5%AE%9E%E4%B9%A0%E8%AE%B0%E5%BD%95/springCloud.png"></p><p>其他相关未做过多了解</p><h4 id="Eureka注册中心高可用集群"><a href="#Eureka注册中心高可用集群" class="headerlink" title="Eureka注册中心高可用集群"></a>Eureka注册中心高可用集群</h4><h4 id="客户端负载均衡Ribbon"><a href="#客户端负载均衡Ribbon" class="headerlink" title="客户端负载均衡Ribbon"></a>客户端负载均衡Ribbon</h4><h4 id="熔断器"><a href="#熔断器" class="headerlink" title="熔断器"></a>熔断器</h4><p>就是当被调用方没有响应时，调用方直接返回一个错误响应即可，而不是长时间的等待，这样避免调用时因为等待而线程一直得不到释放，避免故障在分布式系统间蔓延。<br>使用熔断器Hystrix只需要简单两步，P26</p><p>负载均衡和服务熔断都是Spring cloud中进行微服务开发非常基础的组件，而且一般使用过程中都是同时出现的，配置也非常相似，每次开发都有很多相同的代码，因为整合了两个组件。</p><h4 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h4><h4 id="API网关Zuul"><a href="#API网关Zuul" class="headerlink" title="API网关Zuul"></a>API网关Zuul</h4><p>P37（管理接口、权限验证）</p><h4 id="Spring-Cloud-Config"><a href="#Spring-Cloud-Config" class="headerlink" title="Spring Cloud Config"></a>Spring Cloud Config</h4><p>P45（对各个分布式项目的配置文件的统一管理），搭建配置中心服务端、客户端</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">``` </span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-Spring-Boot&quot;&gt;&lt;a href=&quot;#1-Spring-Boot&quot; class=&quot;headerlink&quot; title=&quot;1. Spring Boot&quot;&gt;&lt;/a&gt;1. Spring Boot&lt;/h2&gt;&lt;p&gt;简单步骤&lt;/p&gt;
&lt;figure class=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Mac下搭建我的博客</title>
    <link href="http://example.com/2021/07/19/Mac%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>http://example.com/2021/07/19/Mac%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/</id>
    <published>2021-07-19T07:19:10.748Z</published>
    <updated>2021-07-22T02:40:05.480Z</updated>
    
    <content type="html"><![CDATA[<p>萌生写blog的想法，花费半天时间使用Hexo、GitHub Pages来搭建自己的个性化博客。</p><h2 id="1-GitHub-Pages"><a href="#1-GitHub-Pages" class="headerlink" title="1. GitHub Pages"></a>1. GitHub Pages</h2><h3 id="1-GitHub账号注册"><a href="#1-GitHub账号注册" class="headerlink" title="(1) GitHub账号注册"></a>(1) GitHub账号注册</h3><p>注册过程省略</p><h3 id="2-创建新的仓库"><a href="#2-创建新的仓库" class="headerlink" title="(2) 创建新的仓库"></a>(2) 创建新的仓库</h3><p>点击右上角头像，选择Your repositories；新界面上选择New,如下填写，Create repository。</p><p><img src="https://yzhangwh-1253708708.cos.ap-shanghai.myqcloud.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/png1.png"></p><h3 id="3-配置SSH-Keys"><a href="#3-配置SSH-Keys" class="headerlink" title="(3) 配置SSH Keys"></a>(3) 配置SSH Keys</h3><p>打开终端，输入命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cd ~/.ssh</span><br></pre></td></tr></table></figure><p>如果提示 No such file or directory 说明是第一次使用 git。<br>接下来生成新的SSH Keys</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ssh-keygen -t rsa -C &quot;yzhangwh@126.com&quot;</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):&lt;回车&gt;</span><br><span class="line">Enter passphrase (empty for no passphrase):&lt;输入加密串&gt;&lt;如不想设置密码可直接回车表示为空&gt;</span><br><span class="line">Enter same passphrase again:&lt;再次输入加密串&gt;&lt;接着回车确认&gt;</span><br></pre></td></tr></table></figure><p>接下来，将SSH key添加到GitHub<br>打开本地生成的.ssh/id_rsa.pub（若看不到，则需显示隐藏文件）,准确复制文件中所有内容。然后进入github主页，点击右上角头像进入settings，选择SSH and GPG keys，再点击New SSH Key。将内容复制进key，title可以为空。最后Add SSH key。<br>测试是否成功</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ssh -T git@GitHub.com</span><br></pre></td></tr></table></figure><p>接下来会出现</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The authenticity of host &#x27;GitHub.com (207.97.227.239)&#x27; can&#x27;t be established.</span><br><span class="line">RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?&lt;输入yes&gt;</span><br><span class="line">Hi 你的用户名! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure><p>代表SSH key添加成功<br>接下来测试github pages是否创建成功</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># echo &quot;# GitZWH-hub.github.io&quot; &gt;&gt; README.md</span><br><span class="line"># git init    </span><br><span class="line"># git add README.md</span><br><span class="line"># git commit -m &quot;first commit&quot;</span><br><span class="line"># git remote add origin https://github.com/GitZWH-hub/GitZWH-hub.github.io.git</span><br><span class="line"># git push -u origin master</span><br></pre></td></tr></table></figure><p>之后浏览器中输入 GitZWH-hub.github.io，如果成功出现页面，则GitHub Pages配置成功。</p><h2 id="2-Hexo"><a href="#2-Hexo" class="headerlink" title="2. Hexo"></a>2. Hexo</h2><h3 id="1-Node-js安装"><a href="#1-Node-js安装" class="headerlink" title="(1) Node.js安装"></a>(1) Node.js安装</h3><p>检查是否有brew</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># brew -v</span><br></pre></td></tr></table></figure><p>如果顺利显示版本号，说明homebrew已经安装。否则，输入以下命令进行安装：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; </span><br></pre></td></tr></table></figure><p>安装Node.js</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># brew link node</span><br><span class="line"># brew uninstall node</span><br><span class="line"># brew install node</span><br></pre></td></tr></table></figure><h3 id="2-Hexo安装"><a href="#2-Hexo安装" class="headerlink" title="(2) Hexo安装"></a>(2) Hexo安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h3 id="3-Hexo建站"><a href="#3-Hexo建站" class="headerlink" title="(3) Hexo建站"></a>(3) Hexo建站</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># hexo init MyGitBlog</span><br><span class="line"># cd MyBigBlog</span><br><span class="line"># npm install</span><br></pre></td></tr></table></figure><h3 id="4-Hexo测试"><a href="#4-Hexo测试" class="headerlink" title="(4) Hexo测试"></a>(4) Hexo测试</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cd MyGitBlog</span><br><span class="line"># hexo clean</span><br><span class="line"># hexo g</span><br><span class="line"># hexo s</span><br></pre></td></tr></table></figure><p>如果出现以下信息，则成功。可进入本地浏览器查看<a href="http://localhost:4000/">localhost:4000</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure><h3 id="5-Hexo部署到Git"><a href="#5-Hexo部署到Git" class="headerlink" title="(5) Hexo部署到Git"></a>(5) Hexo部署到Git</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>修改 _config.yml 文件中的配置如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/GitZWH-hub/GitZWH-Hub.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>⚠️注意：所有的冒号后面都严格要求有一个空格<br>继续执行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># hexo clean</span><br><span class="line"># hexo g</span><br><span class="line"># hexo d</span><br></pre></td></tr></table></figure><p>现在，登录到GitHub Pages 上查看博客<a href="https://gitzwh-hub.github.io/">GitHub Pages</a>。<br>此时，应该可以看到和本地上看到的一样的画面了。</p><h2 id="3-设置主题"><a href="#3-设置主题" class="headerlink" title="3. 设置主题"></a>3. 设置主题</h2><p>这里选用next主题，也可以使用butterfly等主题。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cd MyGitBlog</span><br><span class="line"># git clone https://github.com/iissnan/hexo-theme-next themes/next  #克隆next主题到本地</span><br></pre></td></tr></table></figure><p>在站点根目录下的配置文件 _config.yml 中，找到 theme字段，并将其值更改为 next。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">theme: next  </span><br></pre></td></tr></table></figure><p>验证</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># hexo s</span><br></pre></td></tr></table></figure><p>本地查看 <a href="http://localhost:4000/">localhost:4000</a></p><p><img src="https://yzhangwh-1253708708.cos.ap-shanghai.myqcloud.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/blog_start.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;萌生写blog的想法，花费半天时间使用Hexo、GitHub Pages来搭建自己的个性化博客。&lt;/p&gt;
&lt;h2 id=&quot;1-GitHub-Pages&quot;&gt;&lt;a href=&quot;#1-GitHub-Pages&quot; class=&quot;headerlink&quot; title=&quot;1. GitHu</summary>
      
    
    
    
    
  </entry>
  
</feed>
